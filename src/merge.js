var async = require('async');
var Github = require('github-api');
var util = require('util');
var utils = require('./utils');

function merge(head, base, token, org, callback) {

  var context = {
    git: new Github({
      token: token,
      auth: "oauth"
    }),
    head: head,
    base: base,
    token: token,
    org: org,
    output: []
  };

  async.waterfall(
    [
      utils.getOrgInfo.bind(context),
      utils.getRepos.bind(context),
      mergeToProd.bind(context)
    ],
    function (err) {
      callback(err, context.output);
    }
  );
}

function mergeToProd(callback) {
  var context = this;

  async.eachSeries(
    context.repos,
    createMergePR.bind(context),
    function () {
      callback();
    }
  );
}

function createMergePR(_repo, callback) {
  var context = this;

  var repo = context.git.getRepo(_repo.owner.login, _repo.name);
  repo.name = _repo.name;

  async.series(
    [
      checkForProductionBranch.bind(context, repo),
      checkForExistingPRs.bind(context, repo),
      createPR.bind(context, repo)
    ],
    function () {
      // ignore errors here
      callback();
    }
  );
}

function checkForProductionBranch(repo, callback) {
  var context = this;

  repo.listBranches(function (err, branches) {
    if (branches.indexOf(context.base) > -1) {
      callback();
    }
    else {
      callback(new Error('No ' + context.base + ' branch'));
    }
  });
}

function checkForExistingPRs(repo, callback) {
  var context = this;

  // check if a PR like this already exists and provide a link to it
  repo.listPulls('open', function (err, prs) {
    prs.forEach(function (pullRequest) {
      if (pullRequest.base.ref === context.base && pullRequest.head.ref === context.head) {
        context.output.push({
          type: 'warning',
          msg: util.format('[%s] Existing PR found: %s', repo.name, pullRequest.html_url),
          data: {
            repo: repo.name,
            url: pullRequest.html_url
          }
        });
      }
    });

    callback();
  });
}

function createPR(repo, callback) {
  var context = this;

  var pull = {
    title: 'Merge ' + context.head + ' into ' + context.base,
    body: "This pull request has been automatically generated by repo-walker.",
    base: context.base,
    head: context.head
  };
  repo.createPullRequest(pull, function (err, pullRequest) {
    if (err || typeof pullRequest === 'undefined') {
      context.output.push({
        type: 'passive-info',
        msg: '[' + repo.name + '] Good news: nothing to merge!',
        data: {
          repo: repo.name
        }
      });
      callback();
      return;
    }

    context.output.push({
      type: 'action-info',
      msg: util.format('[%s] Created PR: %s with %d commits [%d add / %d del / %d files]',
        repo.name,
        pullRequest.html_url,
        pullRequest.commits,
        pullRequest.additions,
        pullRequest.deletions,
        pullRequest.changed_files
      ),
      data: {
        repo: repo.name,
        url: pullRequest.html_url,
        commits: pullRequest.commits,
        additions: pullRequest.additions,
        deletions: pullRequest.deletions,
        changed_files: pullRequest.changed_files
      }
    });

    callback();
  });
}


module.exports = merge;
